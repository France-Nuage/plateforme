//! Instance Interface management.
//!
//! Provides the InstanceInterface data model representing network interfaces
//! attached to compute instances within VNets.

use crate::authorization::Resource;
use crate::network::{VNet, VNetFactory};
use chrono::{DateTime, Utc};
use fabrique::{Factory, Persistable};
use sqlx::{Pool, Postgres};
use std::str::FromStr;
use strum_macros::{Display as StrumDisplay, EnumString};
use uuid::Uuid;

/// State of an instance interface.
#[derive(Clone, Debug, Default, StrumDisplay, EnumString, PartialEq)]
#[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
pub enum InterfaceState {
    #[default]
    Pending,
    Active,
    Error,
}

impl From<InterfaceState> for String {
    fn from(value: InterfaceState) -> Self {
        value.to_string()
    }
}

impl From<String> for InterfaceState {
    fn from(value: String) -> Self {
        InterfaceState::from_str(&value).unwrap_or_default()
    }
}

/// InstanceInterface represents a network interface attached to an instance.
#[derive(Clone, Debug, Default, Factory, Persistable, Resource)]
pub struct InstanceInterface {
    /// Unique identifier
    #[fabrique(primary_key)]
    pub id: Uuid,
    /// ID of the instance this interface belongs to
    pub instance_id: Uuid,
    /// ID of the VNet this interface is connected to
    #[fabrique(relation = "VNet", referenced_key = "id")]
    pub vnet_id: Uuid,
    /// ID of the IP allocation for this interface
    pub ip_address_id: Option<Uuid>,
    /// MAC address of the interface
    pub mac_address: String,
    /// Device name (e.g., net0, net1)
    pub device_name: String,
    /// Network driver (e.g., virtio)
    pub driver: String,
    /// Whether firewall is enabled on this interface
    pub firewall_enabled: bool,
    /// Rate limit in Mbps (0 = unlimited)
    pub rate_limit_mbps: i32,
    /// Current state
    #[fabrique(as = "String")]
    pub state: InterfaceState,
    /// Creation timestamp
    pub created_at: DateTime<Utc>,
    /// Last update timestamp
    pub updated_at: DateTime<Utc>,
}

impl InstanceInterface {
    /// Find an instance interface by ID.
    pub async fn find_one_by_id(pool: &Pool<Postgres>, id: Uuid) -> Result<InstanceInterface, sqlx::Error> {
        sqlx::query_as::<_, InstanceInterface>("SELECT * FROM instance_interfaces WHERE id = $1")
            .bind(id)
            .fetch_one(pool)
            .await
    }

    /// Find all interfaces for an instance.
    pub async fn find_by_instance_id(pool: &Pool<Postgres>, instance_id: Uuid) -> Result<Vec<InstanceInterface>, sqlx::Error> {
        sqlx::query_as::<_, InstanceInterface>("SELECT * FROM instance_interfaces WHERE instance_id = $1")
            .bind(instance_id)
            .fetch_all(pool)
            .await
    }

    /// Find an interface by MAC address.
    pub async fn find_by_mac_address(pool: &Pool<Postgres>, mac_address: &str) -> Result<Option<InstanceInterface>, sqlx::Error> {
        sqlx::query_as::<_, InstanceInterface>("SELECT * FROM instance_interfaces WHERE mac_address = $1")
            .bind(mac_address)
            .fetch_optional(pool)
            .await
    }

    /// Get security groups attached to this interface.
    pub async fn get_security_group_ids(pool: &Pool<Postgres>, interface_id: Uuid) -> Result<Vec<Uuid>, sqlx::Error> {
        let result: Vec<(Uuid,)> = sqlx::query_as(
            "SELECT security_group_id FROM sg_interface_associations WHERE instance_interface_id = $1"
        )
            .bind(interface_id)
            .fetch_all(pool)
            .await?;

        Ok(result.into_iter().map(|(id,)| id).collect())
    }
}

/// Request to create a new instance interface.
#[derive(Clone, Debug)]
pub struct InstanceInterfaceCreateRequest {
    /// ID of the instance
    pub instance_id: Uuid,
    /// ID of the VNet to connect to
    pub vnet_id: Uuid,
    /// MAC address (should be generated by IPAM)
    pub mac_address: String,
    /// Device name (e.g., net0)
    pub device_name: String,
    /// Network driver (default: virtio)
    pub driver: Option<String>,
    /// Whether to enable firewall
    pub firewall_enabled: bool,
    /// Rate limit in Mbps (0 = unlimited)
    pub rate_limit_mbps: Option<i32>,
    /// ID of the IP allocation
    pub ip_address_id: Option<Uuid>,
}

impl InstanceInterface {
    /// Creates a new instance interface.
    pub async fn create_interface(
        pool: &Pool<Postgres>,
        request: InstanceInterfaceCreateRequest,
    ) -> Result<InstanceInterface, sqlx::Error> {
        let interface = InstanceInterface::factory()
            .id(Uuid::new_v4())
            .instance_id(request.instance_id)
            .vnet_id(request.vnet_id)
            .ip_address_id(request.ip_address_id)
            .mac_address(request.mac_address)
            .device_name(request.device_name)
            .driver(request.driver.unwrap_or_else(|| "virtio".to_string()))
            .firewall_enabled(request.firewall_enabled)
            .rate_limit_mbps(request.rate_limit_mbps.unwrap_or(0))
            .state(InterfaceState::Active)
            .create(pool)
            .await?;

        Ok(interface)
    }

    /// Deletes an instance interface and its security group associations.
    pub async fn delete_interface(pool: &Pool<Postgres>, id: Uuid) -> Result<(), sqlx::Error> {
        // Delete security group associations first
        sqlx::query("DELETE FROM sg_interface_associations WHERE instance_interface_id = $1")
            .bind(id)
            .execute(pool)
            .await?;

        // Delete the interface
        sqlx::query("DELETE FROM instance_interfaces WHERE id = $1")
            .bind(id)
            .execute(pool)
            .await?;

        Ok(())
    }

    /// Generates the Proxmox network configuration string for this interface.
    pub fn to_proxmox_net_config(&self, vnet: &VNet) -> String {
        let mut config_parts = Vec::new();

        // Driver and MAC
        config_parts.push(format!("{}={}", self.driver, self.mac_address));

        // Bridge (VNet bridge ID)
        config_parts.push(format!("bridge={}", vnet.vnet_bridge_id));

        // Firewall
        if self.firewall_enabled {
            config_parts.push("firewall=1".to_string());
        }

        // Rate limit
        if self.rate_limit_mbps > 0 {
            config_parts.push(format!("rate={}", self.rate_limit_mbps));
        }

        config_parts.join(",")
    }
}
